<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Linguistic Datasets Analysis</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet">
    <link href="style.css" type="text/css" rel="stylesheet">
  </head>
  <body>

    <header id="header" class="header">
      <div class ="row">
        <div class = "col-sm-1"></div>
        <h1 class = "col-sm-5" style="font-size:24px;" >Linguistic Datasets Analysis</h1>
        <nav class = "col-sm-6 text-right">
          <a href = "languageDetail.html">Language Details</a>
          <a href = "detail.html">Data Availability</a>
          <!-- <a href = "design.html">Design</a> -->
          <a href = "about.html">About Us</a>
        </nav>
      </div>



        <div class="header-content">
            <div class="container">
                <div class="row">
                    <div class="col-lg-12">
                        <div class="text-container">
                            <h1>Words in Languages</h1>
                            <p class="p-large">A helper for linguists in morphology using the UM and UD datasets</p>
                        </div>
                    </div> 
                </div> 
            </div>
        </div> 
    </header> 



  <section id = "introduction" class = "container">
    <h2>Introduction</h2>
    <div class = "row">
      <div class ="col-sm-12">
        <p>Morphology is the study of word structures. Computational morphology uses computational methods to facilitate and expand morphological studies as well as tackling NLP problems involving word structures. There are two projects which provide annotated morphological data for multiple languages labeled with universal schemas: <a href="https://unimorph.github.io/" target="_blank" style="color: #0000CD">the Unimorph project</a> and <a href="https://universaldependencies.org/" target="_blank" style="color: #0000CD">the Universal Dependencies project</a>. The Unimorph project (UM) data is more like a lexicon, where the labeled data are words organized in their inflection tables and there is not sentential level context provided. You can click <a href="images/um_example2.png" target="_blank" style="color: #FF8C00">HERE</a> to see the example of UM data for English verb "crash". The Universal Dependencies project (UD) annotates grammar, especially the dependency relations in sentences, but it also provides annotation of morphology in sentences. You can click <a href="images/ud_example2.png" target="_blank" style="color: #FF8C00">HERE</a> to see the example of UD data for an English sentence with verb "crash".</p>

        <p>UM and UD are two of the common datasets people use for computational morphological studies: UM data for computational morphological tasks out of context and UD data for computational morpholological tasks in context. Data are critical for developing good systems. Related to this in computational morphology are two concerns: (1) How complex the morphological system of a language is (i.e. morphological complexity). In general, more complex the morphology is, the more data we need. (2) Whether we have abundant annotated data (i.e. low-resource status). Languages with little data available are called low-resourced languages.</p>

        <p>On this site, you'll find information about languages and language data in these two datasets. In addition, you'll find analysis of the languages based on linguistic studies and UM data about their morphological complexity and their low-resource status.</p>
      </div>
    </div>
  </section>

  <div class= "row" >
    <div class="col-sm-12">
      <h2 style="margin-left: 80px;margin-top: 20px;">Language map</h2>
      <p style="margin-left: 80px;margin-top: 20px;">You can interact with this map to see what languages in each country have been covered in UM or UD.</p>
    </div>

    <div class="column col-sm-8">
        <svg id="map" >
        <rect width="100%" height="100%" stroke="white" stroke-width="3" fill="#c8def7" opacity="0.2"/>
        </svg>
    </div>
    <div class="col-sm-4">
      <div id="wordcloud"></div>
    </div>


  </div>

    <section id = "viz1" class = "container">
      <div class = "row">
        <div class ="col-sm-5" style="margin-top: 100px;">
<!--          <h2>Language and Typology</h2>-->
          <li>
            Linguistic studies classify languages according to their common morphological structures into Analytical and Synthetic. Synthetic morphological can by further classified into Agglutinative, Fusional, Polysynthetic, and Oligosynthetic. For the data in UM, morphological typology is annotated. However, only two types of typology are used: Agglutinative and Fusional. Languages in UM but not UD does not have typology annotation. Different typologies vary as to the morphological complexity.
          </li>
          <li>
            The irregular pie chart shows the distribution of typologies in the two datasets.
            Among the 199 languages in the corpus, 57% of them are fusional languages, 18.84% are Agglutinative languages and the rest have no typology annotation.
          </li>
        </div>
        <div class = "col-sm-7">
          <img class ="portrait" src = "images/Language&Typology.png">
        </div>
        </div>
    </section>

    <section id = "viz2" class = "container">
      <div class = "row">
        <div class = "col-sm-12">
          <img class ="portrait" src = "images/MeanTableSize02.png">
        </div>
        <div class ="col-sm-12">
          <li>
            Mean table size of a language is how many different inflected forms does the language have for each inflected word in the dataset on average, which is one aspect of morphological complexity.
          </li>
          <li>
            The radial tree visualizes the mean table size of each language and grouped them by typology. Languages with table size as 0 are languages with no data in UM. The largest mean table size is for Basque: 457, meaning that each dictionary form of a word in Basque can appear in as much as 457 forms on average in different context.
          </li>
        </div>
        </div>
    </section>

     <section id = "viz5" class = "container">
      <div class = "row">
        <div class ="col-sm-4" style="margin-top: 50px;">
          <li>
            Language family is a way to group world languages by their genealogy. Languages of the same family are historically related, are descendent of a common ancestral language, and thus are expected to share similarities.
          </li>
          <li>
            The doughnut chart visualizes the language family information of the data in UM and UD. In the chart, more than half of the languages are Indo-European languages, including French, Dutch, Polish, etc.
          </li>
          <li>
            Uralic and Afro-Asiatic are the second and third largest language families. Uralic Languages are predominantly spoken in Northern Eurasia. Afro-Asiatic contains 300 languages that are spoken predominantly in West Asia, North Africa, the Horn of Africa and parts of the Sahel.
          </li>
        </div>
        <div class = "col-sm-8">
          <img class ="portrait" src = "images/LanguageFamilyDist.png">
        </div>
      </div>
    </section>
    
    <section id = "viz6" class = "container">
      <div class = "row">
        <div class = "col-sm-8">
          <img class ="portrait" src = "images/Typology_Family.png">
        </div>
        <div class ="col-sm-4" style="margin-top: 150px;">
          <li>
            We have discussed typology and language family separately above. Now let’s see How the typologies are distributed in different language families. 
          </li>
          <li>
            Apparently the three largest language families are Indo-European, Uralic, and Afro-Asiatic. The dominant typology in Indo-European languages is fusional while in Uralic the number of agglutinative typology languages is a little more than fusional or none typology. In Afro-Asiatic, almost half of the languages are fusional, half are none typology.
          </li>
        </div>
      </div>
    </section>

    <section id = "viz3" class = "container">
      <div class = "row">
        <div class ="col-sm-6" style="margin-top: 20px;">
          <li>
            According to linguistic studies, each affix in agglutinative languages has only one functional meaning while fusional languages usually experess multiple functional meanings with each affix. The number of paradigms is how many dictionary word forms are labeld in UM and the number of forms is how may different inflected forms are labeled in UM. Is there any pattern as to the number of forms and the number of paradigms in relation to the typology of the language?
          </li>
          <li>
            The scatter plot attempts to explore the potential pattern. We can see that for the same number of paradgims, fusional languages tend to have slightly more inflected forms.
          </li>
          <li>
            Note: The visualization is using the logarithm of the form counts and paradigm counts because the numbers of forms of paradigms vary a lot. For languages with not annotated data in UM (i.e. the counts are zeros), we set it to 0.1 before taking logarithm.
          </li>
        </div>
        <div class = "col-sm-6">
          <img class ="portrait" src = "images/Forms-Paradigms.png">
        </div>
      </div>
    </section>


    <section id = "viz4" class = "container">
      <div class = "row">
        <div class = "col-sm-7">
          <img class ="portrait" src = "images/Sentence-Length02.png">
        </div>
        <div class ="col-sm-5" style="margin-top: 100px;">
          <li>
            If a language uses more morphological tactics to express grammatical meanings, it's very likely that this language will use less functional words. Therefore, we expect languages with larger average table size to have shorter sentences on average. Is this linguistic hypothesis true or not?
          </li>
          <li>
            The scatter plot about the average table size and average sentence length visualize information we need to answer this question. Most of the dots cluster around the top left corner of the plot, and few languages are at the top right. This supports the linguistic hypothesis.
          </li>
        </div>
        </div>
    </section>


    <section id = "viz7" class = "container">
      <div class = "row">
        <div class = "col-sm-12">
          <img class ="portrait" src = "images/Low Resource.png">
        </div>
        <div class ="col-sm-12" style="margin-bottom: 50px;">
          <li>
            Low-resourced languages are a big concern of linguistic studies. The treemap shows information about low-resource languages, which are UM and UD languages that have limited annotated data in UM.
          </li>
          <li>
            Low resources languages contain more language families than the normal resource languages. Afro-Asiatic languages have only 4 languages that are not low resources and the rest 9 languages are all low resource languages. Another language family that contains more low resource languages than not low resource languages is Niger-Congo. Both Afro-Asiatic and Niger-Congo languages are widely spoken in Africa, which reflects a fact: There are many endangered languages on African land that need us to protect.  
          </li>
        </div>
      </div>
    </section>



    <center><button class="button" type="button" onclick="{location.href='languageDetail.html'}" style="background-color: #7892C2; border: none; color: white; padding: 10px;text-align: center;text-decoration: none;display: inline-block;font-size: 20px;margin: 4px 2px;cursor: pointer;border-radius: 14px;">See more details of each language</button>
    <div class="container" style="margin-top: 20px;">
      <div class="infogram-embed" data-id="0ef08eb1-a264-455d-a42c-f836d308cd1e" data-type="interactive" data-title="Autumn Charts"></div><script>!function(e,i,n,s){var t="InfogramEmbeds",d=e.getElementsByTagName("script")[0];if(window[t]&&window[t].initialized)window[t].process&&window[t].process();else if(!e.getElementById(n)){var o=e.createElement("script");o.async=1,o.id=n,o.src="https://e.infogram.com/js/dist/embed-loader-min.js",d.parentNode.insertBefore(o,d)}}(document,0,"infogram-async");</script><div style="padding:8px 0;font-family:Arial!important;font-size:13px!important;line-height:15px!important;text-align:center;border-top:1px solid #dadada;margin:0 30px"><a href="https://infogram.com/0ef08eb1-a264-455d-a42c-f836d308cd1e" style="color:#989898!important;text-decoration:none!important;" target="_blank">Example：Arabic Detail</a></div>
    </div>



  <div id="gotop">
    <div class="arrow"></div>
    <div class="stick"></div>
  </div>




    <footer class = "container" >
        <div class = "row" >
          <p>&copy; 2019 INFO 5602 Group 6</p>
        </div>
    </footer>

<script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/queue.v1.min.js"></script>
  <script src="https://d3js.org/topojson.v1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js"></script>
  <!-- Color scale -->
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <script>

    // Set tooltips for map
    var tip = d3.tip() //https://github.com/caged/d3-tip/blob/master/docs/index.md
            .attr('class', 'd3-tip')
            .direction('n')
            // .offset([0, 0]) //https://github.com/caged/d3-tip/blob/master/docs/positioning-tooltips.md
            .html(function(d) {
              return "<span class='detailsCountryName'>" + d.properties.name + "<br></span>"
                     + "<strong> Unimorph & UD dataset</strong><br>"
                     + "<span class='details'> Total languages:" + format(d.participantnum) +"<br></span>"
                     // + "<span class='details'> > by Self-Identify: " + format(d.participantnumSelf) +"</span>";
            });

    /*
    D3.js setup code
    */
    var margin = {top: 10, right: 0, bottom: 0, left: 10};
    var width = 600 - margin.left - margin.right;
    var height = 500 - margin.top - margin.bottom;

    var color = d3.scaleThreshold()
                  .domain([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17])
                  .range(["rgb(209, 209, 176)","rgb(245, 245, 120)", "rgb(199,233,180)", "rgb(170, 227, 138)","rgb(78, 212, 160)","rgb(127,205,187)", "rgb(114, 188, 196)", "rgb(65,182,196)","rgb(47, 166, 214)", "rgb(29,145,192)","rgb(23, 108, 212)","rgb(34,94,168)","rgb(37,52,148)","rgb(8,29,88)","rgb(2,56,88)"]);

    var format = d3.format(","); //https://github.com/d3/d3-format

    // Source: https://github.com/d3/d3-geo
    var projection = d3.geoMercator()
                   .scale(120) // adjust the size of the map
                  .translate( [width /1.6, height/1.2]); //adjust the location of the map on the canvas

    var path = d3.geoPath().projection(projection);

    ////////////////////////////////////////////////

    // load data with queue
    var countryloc = "world_countries.json";
    var surveryinfo = "countryToLanguage.csv";

    var q = queue()
            .defer(d3.json, countryloc)
            .defer(d3.csv, surveryinfo)
            .awaitAll(draw);

    function draw(error, data) {

    // important: First argument it expects is error
    if (error) throw error;
    // console.log(data);

    var mapData = data[0];
    var surveyData = data[1];
    // console.log(mapData);
    // console.log(surveyData);

    surveyData.forEach(function (d) {
      if (d.Country === ""){
         d.Country = "NA";
      }
        // console.log(d);
    });

    // surveyData.forEach(function (d) {
    //   if (d["I consider myself:"].includes("Average User")) {
    //     d["I consider myself:"] = "Average User";
    //   } else if (d["I consider myself:"].includes("Technically Savvy")) {
    //     d["I consider myself:"] = "Technically Savvy";
    //   } else if (d["I consider myself:"].includes("Ultra Nerd")) {
    //      d["I consider myself:"] = "Ultra Nerd";
    //   } else if (d["I consider myself:"].includes("Luddite")) {
    //      d["I consider myself:"] = "Luddite";
    //   } else {
    //      d["I consider myself:"] = "NaN";
    //   }
    //     // console.log(d);
    // });

    // surveyData.forEach(function (d) {
    //   if (d["Country or Region (optional)"] === "") {
    //      d["Country or Region (optional)"] = "NA";
    //   }

    //   surveyData.forEach(function (d) {
    //     if (d["Country"] === "") {
    //      d["Country"] = "NA";
    //   }
    //     // console.log(d);
    // });


    /*
    Map starts
    - count categorical variables
      Source: http://www.shanegibney.com/shanegibney/d3-js-v4-count-values-in-an-object/
    */
    var countryCount = d3.nest()
        .key(function (d) {
            return d.Country;
        })
        .rollup(function (leaves) {
            return leaves.length;
        })
        .entries(surveyData);


    var countryCountDict = {};
    countryCount.forEach(function (d) {
        countryCountDict[d.key] = +d.value;
    });
    // console.log(countryCountDict);

    mapData.features.forEach(function (d) {
        d.participantnum = countryCountDict[d.properties.name];
        // console.log(d);
    });


    ///////// country/region reported by the participants themselves ///////////

    var countryCountSelf = d3.nest()
        .key(function (d) {
            // return d["Country or Region (optional)"];
            return d["Country"];
        })
        .rollup(function (leaves) {
            return leaves.length;
        })
        .entries(surveyData);

    var countryCountSelfDict = {};
    countryCountSelf.forEach(function (d) {
        countryCountSelfDict[d.key] = +d.value;
    });
    // console.log(countryCountDict);

    mapData.features.forEach(function (d) {
        d.participantnumSelf = countryCountSelfDict[d.properties.name];
        // console.log(d);
    });

    // create and append the map of SF neighborhoods
    var map = d3.select('#map')
                 .selectAll('path')
                 .data(mapData.features)
                 .enter()
                 .append('path')
                 .attr('d', path)
                 .attr('width', width)
                 .attr('height', height)
                 // add the neighborhood name as its class
                 .attr('class', function(d) {
                    return d.properties.name;
                 })

                 .style("fill", function(d) {
                   if (typeof d.participantnum !== 'undefined') {
                      return color(d.participantnum);
                   } else {
                       return "gray"
                     }})
                 .style('stroke', 'white')
                 .style('stroke-width', 1.5)
                 .style("opacity",0.8)
        .on('mouseover',function(d){
          d3.select(this)
            .style("fill", "pink")
            .style("stroke","white")
            .style("stroke-width",3);
          tip.show(d);
          var cname = d.properties.name;
          console.log(cname)
          func_text_cloud(cname);
          // drawChart(cname);
          // drawBarChart(cname);
        })
        .on('click',function(d){
          d3.select(this)
            .style("fill", "pink")
            .style("stroke","white")
            .style("stroke-width",3);
          tip.show(d);
          var cname = d.properties.name;
          console.log(cname)
          func_text_cloud(cname);
          // drawChart(cname);
          // drawBarChart(cname);
        })
        .on('mouseout', function(d){
          tip.hide(d);
          d3.selectAll("#wordcloud > *").remove();;
          // svg.selectAll("*").
          // var cname = d.properties.name;
          d3.select(this)
          // d3.select("path." + cname)
            .style("opacity", 0.8)
            .style("fill", function(d) {
                   if (typeof d.participantnum !== 'undefined') {
                      return color(d.participantnum);
                   } else {
                       return "gray"
                     }})
            .style("stroke","white")
            .style("stroke-width",0.3);
        });

    map.call(tip);

    // add legend
    var legend = d3.select('#map').selectAll(".legend")
                        .data(color.domain())
                        .enter().append("g")
                        .attr("class", "legend")
                        .attr("transform", function(d, i){
                          return "translate(0," + (i * 20) + ")"
                        });
        legend.append("rect")
              .attr("x", width+190)
                .attr("y", 20)
              .attr("width", 18)
              .attr("height", 18)
              .style("fill", color);

        legend.append("text")
              .attr("x", width+175)
              .attr("y", 30)
              .attr("dy", ".35em")
              .style("text-anchor", "end")
              .text(function(d){return d;});

        d3.select("#map").append('text')
                .attr("x", width+170)
                .attr("y", 15)
                      .attr("dy", "0em")
                      .style("font-size", "1em")
                      .style("text-anchor", "middle")
                      .text("Threshold");


    /*
     Map ends
    */

    // Text cloud source: https://www.d3-graph-gallery.com/graph/wordcloud_custom.html
    function func_text_cloud(country_name) {
      var combinedData = "combinedData.csv";
      // var country_name = 'Germany';

      var q_2 = queue()
          .defer(d3.csv, combinedData)
          .defer(d3.csv, surveryinfo)
          .awaitAll(text_show);

      function text_show(error, data) {
        // important: First argument it expects is error
        if (error) throw error;
        // console.log(data);

        console.log("-----------------")
        var mapData = data[0];
        var surveyData = data[1];
        // console.log(mapData);
        console.log(surveyData);

        var countryCount = d3.map(surveyData, function(d) {return d.Language}).keys()

        var myWords = [];

        surveyData.forEach(function (d_1) {
          if(d_1.Country == country_name) {
            var country_size = 20;
            mapData.forEach(function (d_2) {
              if(d_2.Language == d_1.Language) {
                // country_size = d_2.Paradigms;
              }
            });
            myWords.push({word: d_1.Language, size: country_size});
          }
        });
        console.log(myWords);

        // List of words
        // var myWords = [{word: "German", size: "50"}, {word: "Gothic", size: "50"}, {word: "Low German", size: "50"}, {word: "Lower Sorbian", size: "50"}, {word: "Middle High German", size: "50"}, {word: "Middle Low German", size: "50"},{word: "North Frisian", size: "50"},{word: "Old Saxon", size: "50"},{word: "Yiddish", size: "50"},{word: "Saterfriesisch", size: "50"}, {word: "Upper Sorbian", size: "50"}]

        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 10, bottom: 10, left: 10},
            width = 350 - margin.left - margin.right,
            height = 550 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#wordcloud").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");

        // Constructs a new cloud layout instance. It run an algorithm to find the position of words that suits your requirements
        // Wordcloud features that are different from one word to the other must be here
        var fill = d3.scaleOrdinal(d3.schemeCategory20);
        var layout = d3.layout.cloud()
          .size([width, height])
          .words(myWords.map(function(d) { return {text: d.word, size:d.size}; }))
          .padding(10)        //space between words
          .rotate(function() { return ~~(Math.random() * 2) * 65; })
          .fontSize(function(d) { return d.size; })      // font size of words
          .on("end", draw);
        layout.start();

        // This function takes the output of 'layout' above and draw the words
        // Wordcloud features that are THE SAME from one word to the other can be here
        function draw(words) {
          svg
            .append("g")
              .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
              .selectAll("text")
                .data(words)
              .enter().append("text")
                .style("font-size", function(d) { return d.size; })
                // .style("fill", "#69b3a2")
                .style("fill", (d, i) => fill(i))
                .attr("text-anchor", "middle")
                .style("font-family", "Montserrat")
                .attr("transform", function(d) {
                  return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                })
                .text(function(d) { return d.text; });
        }
      };
    };
    

    }



    </script>
    <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3.layout.cloud.js"></script>
    <script src="http://cdn.staticfile.org/jquery/1.11.1-rc2/jquery.min.js"></script>
    <script>
      $(function(){

          $(window).scroll(function(){  

              var scrollt = document.documentElement.scrollTop + document.body.scrollTop; 

              if( scrollt >600 ){  

                  $("#gotop").fadeIn(400); 

              }else{

                  $("#gotop").stop().fadeOut(400); 

              }

          });

          $("#gotop").click(function(){ 

              $("html,body").animate({scrollTop:"0px"},200);

          }); 

      });
    </script>
  </body>
</html>
